// Copyright 2014 The Cockroach Authors.
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//      http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied. See the License for the specific language governing
//  permissions and limitations under the License. See the AUTHORS file
//  for names of contributors.
//  Author: Spencer Kimball (spencer.kimball@gmail.com)

syntax = "proto2";

import "cockroach/proto/metadata.proto";
import "cockroach/proto/data.proto";
import "cockroach/proto/errors.proto";
package cockroach.proto;

option go_package = "proto";

// ReadConsistencyType specifies what type of consistency is observed
//  during read operations.
enum ReadConsistencyType {
  // CONSISTENT reads are guaranteed to read committed data; the
  //  mechanism relies on clocks to determine lease expirations.
  CONSISTENT = 0;
  // CONSENSUS requires that reads must achieve consensus. This is a
  //  stronger guarantee of consistency than CONSISTENT.
  //  TODO(spencer): current unimplemented.
  CONSENSUS = 1;
  // INCONSISTENT reads return the latest available, committed values.
  //  They are more efficient, but may read stale values as pending
  //  intents are ignored.
  INCONSISTENT = 2;
}

// TxnPushType determines what action to take when pushing a
//  transaction.
enum PushTxnType {
  // Push the timestamp forward if possible to accommodate a concurrent reader.
  PUSH_TIMESTAMP = 0;
  // Abort the transaction if possible to accommodate a concurrent writer.
  ABORT_TXN = 1;
  // Cleanup the transaction if already committed/aborted, or if too old.
  CLEANUP_TXN = 2;
}

// ClientCmdID provides a unique ID for client commands. Clients which
//  provide ClientCmdID gain operation idempotence. In other words,
//  clients can submit the same command multiple times and always
//  receive the same response. This is common on retries over flaky
//  networks. However, the system imposes a limit on how long
//  idempotence is provided. Retries over an hour old are not
//  guaranteed idempotence and may be executed more than once with
//  potentially different results.
//  ClientCmdID contains the client's timestamp and a client-generated
//  random number. The client Timestamp is specified in unix
//  nanoseconds and is used for some uniqueness but also to provide a
//  rough ordering of requests, useful for data locality on the
//  server. The Random is specified for additional uniqueness.
//  NOTE: An accurate time signal IS NOT required for correctness.
message ClientCmdID {
  // Nanoseconds since Unix epoch.
  optional int64 wall_time = 1;
  optional int64 random = 2;
}

// RequestHeader is supplied with every storage node request.
message RequestHeader {
  // Timestamp specifies time at which read or writes should be
  //  performed. If the timestamp is set to zero value, its value
  //  is initialized to the wall time of the receiving node.
  optional .cockroach.proto.Timestamp timestamp = 1;
  // CmdID is optionally specified for request idempotence
  //  (i.e. replay protection).
  optional .cockroach.proto.ClientCmdID cmd_id = 2;
  // The key for request. If the request operates on a range, this
  //  represents the starting key for the range.
  optional bytes key = 3;
  // The end key is empty if the request spans only a single key. Otherwise,
  //  it must order strictly after Key. In such a case, the header indicates
  //  that the operation takes place on the key range from Key to EndKey,
  //  including Key and excluding EndKey.
  optional bytes end_key = 4;
  // Replica specifies the destination for the request. This is a specific
  //  instance of the available replicas belonging to RangeID.
  optional .cockroach.proto.Replica replica = 5;
  // RangeID specifies the ID of the Raft consensus group which the key
  //  range belongs to. This is used by the receiving node to route the
  //  request to the correct range.
  optional int64 range_id = 6;
  // UserPriority specifies priority multiple for non-transactional
  //  commands. This value should be a positive integer [1, 2^31-1).
  //  It's properly viewed as a multiple for how likely this
  //  transaction will be to prevail if a write conflict occurs.
  //  Commands with UserPriority=100 will be 100x less likely to be
  //  aborted as conflicting transactions or non-transactional commands
  //  with UserPriority=1. This value is ignored if Txn is
  //  specified. If neither this value nor Txn is specified, the value
  //  defaults to 1.
  optional int32 user_priority = 7 [default = 1];
  // Txn is set non-nil if a transaction is underway. To start a txn,
  //  the first request should set this field to non-nil with name and
  //  isolation level set as desired. The response will contain the
  //  fully-initialized transaction with txn ID, priority, initial
  //  timestamp, and maximum timestamp.
  optional .cockroach.proto.Transaction txn = 8;
  // ReadConsistency specifies the consistency for read
  //  operations. The default is CONSISTENT. This value is ignored for
  //  write operations.
  optional .cockroach.proto.ReadConsistencyType read_consistency = 9;
}

// ResponseHeader is returned with every storage node response.
message ResponseHeader {
  // Error is non-nil if an error occurred.
  optional .cockroach.proto.Error error = 1;
  // Timestamp specifies time at which read or write actually was
  //  performed. In the case of both reads and writes, if the timestamp
  //  supplied to the request was 0, the wall time of the node
  //  servicing the request will be set here. Additionally, in the case
  //  of writes, this value may be increased from the timestamp passed
  //  with the RequestHeader if the key being written was either read
  //  or written more recently.
  optional .cockroach.proto.Timestamp timestamp = 2;
  // Transaction is non-nil if the request specified a non-nil
  //  transaction. The transaction timestamp and/or priority may have
  //  been updated, depending on the outcome of the request.
  optional .cockroach.proto.Transaction txn = 3;
}

// A GetRequest is the argument for the Get() method.
message GetRequest {
  optional .cockroach.proto.RequestHeader header = 1;
}

// A GetResponse is the return value from the Get() method.
//  If the key doesn't exist, returns nil for Value.Bytes.
message GetResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
  optional .cockroach.proto.Value value = 2;
}

// A PutRequest is the argument to the Put() method.
message PutRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  optional .cockroach.proto.Value value = 2;
}

// A PutResponse is the return value from the Put() method.
message PutResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A ConditionalPutRequest is the argument to the ConditionalPut() method.
//  - Returns true and sets value if ExpValue equals existing value.
//  - If key doesn't exist and ExpValue is nil, sets value.
//  - If key exists, but value is empty and ExpValue is not nil but empty, sets value.
//  - Otherwise, returns error and the actual value of the key in the response.
message ConditionalPutRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  // The value to put.
  optional .cockroach.proto.Value value = 2;
  // ExpValue.Bytes empty to test for non-existence. Specify as nil
  //  to indicate there should be no existing entry. This is different
  //  from the expectation that the value exists but is empty.
  optional .cockroach.proto.Value exp_value = 3;
}

// A ConditionalPutResponse is the return value from the
//  ConditionalPut() method.
message ConditionalPutResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// An IncrementRequest is the argument to the Increment() method. It
//  increments the value for key, and returns the new value. If no
//  value exists for a key, incrementing by 0 is not a noop, but will
//  create a zero value. IncrementRequest cannot be called on a key set
//  by Put() or ConditionalPut(). Similarly, Put() and ConditionalPut()
//  cannot be invoked on an incremented key.
message IncrementRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  optional int64 increment = 2;
}

// An IncrementResponse is the return value from the Increment
//  method. The new value after increment is specified in NewValue. If
//  the value could not be decoded as specified, Error will be set.
message IncrementResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
  optional int64 new_value = 2;
}

// A DeleteRequest is the argument to the Delete() method.
message DeleteRequest {
  optional .cockroach.proto.RequestHeader header = 1;
}

// A DeleteResponse is the return value from the Delete() method.
message DeleteResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A DeleteRangeRequest is the argument to the DeleteRange() method. It
//  specifies the range of keys to delete.
message DeleteRangeRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  // If 0, *all* entries between Key (inclusive) and EndKey
  //  (exclusive) are deleted. Must be >= 0.
  optional int64 max_entries_to_delete = 2;
}

// A DeleteRangeResponse is the return value from the DeleteRange()
//  method.
message DeleteRangeResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
  // Number of entries removed.
  optional int64 num_deleted = 2;
}

// A ScanRequest is the argument to the Scan() method. It specifies the
//  start and end keys for an ascending scan of [start,end) and the maximum
//  number of results.
message ScanRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  // If 0, there is no limit on the number of retrieved entries. Must be >= 0.
  optional int64 max_results = 2;
}

// A ScanResponse is the return value from the Scan() method.
message ScanResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
  // Empty if no rows were scanned.
  repeated .cockroach.proto.KeyValue rows = 2;
}

// A ReverseScanRequest is the argument to the ReverseScan() method. It specifies the
//  start and end keys for a descending scan of [start,end) and the maximum
//  number of results.
message ReverseScanRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  // If 0, there is no limit on the number of retrieved entries. Must be >= 0.
  optional int64 max_results = 2;
}

// A ReverseScanResponse is the return value from the ReverseScan() method.
message ReverseScanResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
  // Empty if no rows were scanned.
  repeated .cockroach.proto.KeyValue rows = 2;
}

// An EndTransactionRequest is the argument to the EndTransaction() method. It
//  specifies whether to commit or roll back an extant transaction.
message EndTransactionRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  // False to abort and rollback.
  optional bool commit = 2;
  // Optional commit triggers. Note that commit triggers are for
  //  internal use only and will cause an error if requested through the
  //  external-facing KV API.
  optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
  // List of intents written by the transaction.
  repeated .cockroach.proto.Intent intents = 4;
}

// An EndTransactionResponse is the return value from the
//  EndTransaction() method. The final transaction record is returned
//  as part of the response header. In particular, transaction status
//  and timestamp will be updated to reflect final committed
//  values. Clients may propagate the transaction timestamp as the
//  final txn commit timestamp in order to preserve causal ordering
//  between subsequent transactions. CommitWait specifies the commit
//  wait, which is the remaining time the client MUST wait before
//  signalling completion of the transaction to another distributed
//  node to maintain consistency.
message EndTransactionResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
  // Remaining time (ns).
  optional int64 commit_wait = 2;
  // TODO(tschottdorf): remove this
  // List of intents resolved by EndTransaction call.
  repeated bytes resolved = 3;
}

// An AdminSplitRequest is the argument to the AdminSplit() method. The
//  existing range which contains RequestHeader.Key is split by
//  split_key. If split_key is not specified, then this method will
//  determine a split key that is roughly halfway through the
//  range. The existing range is resized to cover only its start key to
//  the split key. The new range created by the split starts at the
//  split key and extends to the original range's end key. If split_key
//  is known, header.key should also be set to split_key.
//  New range IDs for each of the split range's replica and a new Raft
//  ID are generated by the operation. Split requests are done in the
//  context of a distributed transaction which updates range addressing
//  records, range metadata and finally, provides a commit trigger to
//  update bookkeeping and instantiate the new range on commit.
//  The new range contains range replicas located on the same stores;
//  no range data is moved during this operation. The split can be
//  thought of as a mostly logical operation, though some other
//  metadata (e.g. response cache and range stats must be copied or
//  recomputed).
message AdminSplitRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  optional bytes split_key = 2;
}

// An AdminSplitResponse is the return value from the AdminSplit()
//  method.
message AdminSplitResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// An AdminMergeRequest is the argument to the AdminMerge() method. A
//  merge is performed by calling AdminMerge on the left-hand range of
//  two consecutive ranges (i.e. the range which contains keys which
//  sort first). This range will be the subsuming range and the right
//  hand range will be subsumed. After the merge operation, the
//  subsumed_range will no longer exist and the subsuming range will
//  now encompass all keys from its original start key to the end key
//  of the subsumed range. If AdminMerge is called on the final range
//  in the key space, it is a noop.
message AdminMergeRequest {
  optional .cockroach.proto.RequestHeader header = 1;
}

// An AdminMergeResponse is the return value from the AdminMerge()
//  method.
message AdminMergeResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A RangeLookupRequest is arguments to the RangeLookup() method. A
//  forward lookup request returns a range containing the requested
//  key. A reverse lookup request returns a range containing the
//  previous key of the requested key (e.g., if a requested key is the
//  end key of range R, the reverse lookup request returns R).
//  RangeLookupRequest also specifies the maximum number of range
//  descriptors that should be returned, if there are additional
//  consecutive addressable ranges. Specify max_ranges > 1 to pre-fill the
//  range descriptor cache. The additional ranges are scanned in the same
//  direction as lookup (forward v.s. reverse).
message RangeLookupRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  optional int32 max_ranges = 2;
  // ConsiderIntents indicates whether or not intents encountered
  //  while looking up the range info should randomly be returned
  //  to the caller. This is intended to be used when retrying due
  //  to range addressing errors.
  optional bool consider_intents = 3;
  // Use a reverse scan to pre-fill the range descriptor cache instead
  //  of an ascending scan.
  optional bool reverse = 4;
}

// A RangeLookupResponse is the return value from the RangeLookup()
//  method. It returns metadata for the range containing the requested
//  key, optionally returning the metadata for additional consecutive
//  ranges beyond the requested range to pre-fill the range descriptor
//  cache.
message RangeLookupResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
  repeated .cockroach.proto.RangeDescriptor ranges = 2;
}

// A HeartbeatTxnRequest is arguments to the HeartbeatTxn()
//  method. It's sent by transaction coordinators to let the system
//  know that the transaction is still ongoing. Note that this
//  heartbeat message is different from the heartbeat message in the
//  gossip protocol.
message HeartbeatTxnRequest {
  optional .cockroach.proto.RequestHeader header = 1;
}

// A HeartbeatTxnResponse is the return value from the HeartbeatTxn()
//  method. It returns the transaction info in the response header. The
//  returned transaction lets the coordinator know the disposition of
//  the transaction (i.e. aborted, committed, or pending).
message HeartbeatTxnResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A GCRequest is arguments to the GC() method. It's sent by range
//  leaders after scanning range data to find expired MVCC values.
message GCRequest {
  message GCKey {
    optional bytes key = 1;
    optional .cockroach.proto.Timestamp timestamp = 2;
  }
  optional .cockroach.proto.RequestHeader header = 1;
  optional .cockroach.proto.GCMetadata gc_meta = 2;
  repeated .cockroach.proto.GCRequest.GCKey keys = 3;
}

// A GCResponse is the return value from the GC() method.
message GCResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A PushTxnRequest is arguments to the PushTxn() method. It's sent by
//  readers or writers which have encountered an "intent" laid down by
//  another transaction. The goal is to resolve the conflict. Note that
//  args.Key should be set to the txn ID of args.PusheeTxn, not
//  args.PusherTxn (which might be nil in any case). This RPC is
//  addressed to the range which owns the pushee's txn record.
//  Resolution is trivial if the txn which owns the intent has either
//  been committed or aborted already. Otherwise, the existing txn can
//  either be aborted (for write/write conflicts), or its commit
//  timestamp can be moved forward (for read/write conflicts). The
//  course of action is determined by the specified push type, and by
//  the owning txn's status and priority.
message PushTxnRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  // Transaction which encountered the intent, if applicable. For a
  //  non-transactional operation, pusher_txn will be nil. Used to
  //  compare priorities and timestamps if priorities are equal.
  optional .cockroach.proto.Transaction pusher_txn = 2;
  // Transaction to be pushed, as specified at the intent which led to
  //  the push transaction request. Note that this may not be the most
  //  up-to-date value of the transaction record, but will be set or
  //  merged as appropriate.
  optional .cockroach.proto.Transaction pushee_txn = 3;
  // Now holds the timestamp used to compare the last heartbeat of the pushee
  //  against. This is necessary since the request header's timestamp does not
  //  necessarily advance with the node clock across retries and hence cannot
  //  detect abandoned transactions.
  optional .cockroach.proto.Timestamp now = 4;
  // Readers set this to PUSH_TIMESTAMP to move PusheeTxn's commit
  //  timestamp forward. Writers set this to ABORT_TXN to request that
  //  the PushTxn be aborted if possible. This is done in the event of
  //  a writer conflicting with PusheeTxn. Inconsistent readers set
  //  this to CLEANUP_TXN to determine whether dangling intents
  //  may be resolved.
  optional .cockroach.proto.PushTxnType push_type = 5;
}

// A PushTxnResponse is the return value from the PushTxn() method. It
//  returns success and the resulting state of PusheeTxn if the
//  conflict was resolved in favor of the caller; the caller should
//  subsequently invoke ResolveIntent() on the conflicted key. It
//  returns an error otherwise.
message PushTxnResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
  // pushee_txn is non-nil if the transaction was pushed and contains
  //  the current value of the transaction.
  optional .cockroach.proto.Transaction pushee_txn = 2;
}

// A ResolveIntentRequest is arguments to the ResolveIntent()
//  method. It is sent by transaction coordinators after success
//  calling PushTxn to clean up write intents: either to remove, commit
//  or move them forward in time.
message ResolveIntentRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  // The transaction whose intent is being resolved.
  optional .cockroach.proto.Transaction intent_txn = 2;
}

// A ResolveIntentResponse is the return value from the
//  ResolveIntent() method.
message ResolveIntentResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A ResolveIntentRangeRequest is arguments to the ResolveIntentRange() method.
//  It is sent by transaction coordinators after success calling PushTxn to
//  clean up write intents: either to remove, commit or move them forward in
//  time.
message ResolveIntentRangeRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  // The transaction whose intents are being resolved.
  optional .cockroach.proto.Transaction intent_txn = 2;
}

// A NoopResponse is the return value from a no-op operation.
message NoopResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A NoopRequest is a no-op.
message NoopRequest {
  optional .cockroach.proto.RequestHeader header = 1;
}

// A ResolveIntentRangeResponse is the return value from the
//  ResolveIntent() method.
message ResolveIntentRangeResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A MergeRequest contains arguments to the Merge() method. It
//  specifies a key and a value which should be merged into the
//  existing value at that key.
message MergeRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  optional .cockroach.proto.Value value = 2;
}

// MergeResponse is the response to a Merge() operation.
message MergeResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// TruncateLogRequest is used to remove a prefix of the raft log. While there
//  is no requirement for correctness that the raft log truncation be synchronized across
//  replicas, it is nice to preserve the property that all replicas of a range are as close
//  to identical as possible. The raft leader can also inform decisions about the cutoff point
//  with its knowledge of the replicas' acknowledgement status.
message TruncateLogRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  // Log entries < this index are to be discarded.
  optional uint64 index = 2;
}

// TruncateLogResponse is the response to a TruncateLog() operation.
message TruncateLogResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A LeaderLeaseRequest is arguments to the LeaderLease()
//  method. It is sent by the store on behalf of one of its ranges upon receipt
//  of a leader election event for that range.
message LeaderLeaseRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  optional .cockroach.proto.Lease lease = 2;
}

// A LeaderLeaseResponse is the response to a LeaderLease()
//  operation.
message LeaderLeaseResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
}

// A RequestUnion contains exactly one of the optional requests.
//  The values added here must match those in ResponseUnion.
message RequestUnion {
  optional .cockroach.proto.GetRequest get = 1;
  optional .cockroach.proto.PutRequest put = 2;
  optional .cockroach.proto.ConditionalPutRequest conditional_put = 3;
  optional .cockroach.proto.IncrementRequest increment = 4;
  optional .cockroach.proto.DeleteRequest delete = 5;
  optional .cockroach.proto.DeleteRangeRequest delete_range = 6;
  optional .cockroach.proto.ScanRequest scan = 7;
  optional .cockroach.proto.EndTransactionRequest end_transaction = 8;
  optional .cockroach.proto.AdminSplitRequest admin_split = 9;
  optional .cockroach.proto.AdminMergeRequest admin_merge = 10;
  optional .cockroach.proto.HeartbeatTxnRequest heartbeat_txn = 11;
  optional .cockroach.proto.GCRequest gc = 12;
  optional .cockroach.proto.PushTxnRequest push_txn = 13;
  optional .cockroach.proto.RangeLookupRequest range_lookup = 14;
  optional .cockroach.proto.ResolveIntentRequest resolve_intent = 15;
  optional .cockroach.proto.ResolveIntentRangeRequest resolve_intent_range = 16;
  optional .cockroach.proto.MergeRequest merge = 17;
  optional .cockroach.proto.TruncateLogRequest truncate_log = 18;
  optional .cockroach.proto.LeaderLeaseRequest leader_lease = 19;
  optional .cockroach.proto.ReverseScanRequest reverse_scan = 20;
  optional .cockroach.proto.NoopRequest noop = 21;
}

// A ResponseUnion contains exactly one of the optional responses.
//  The values added here must match those in RequestUnion.
message ResponseUnion {
  optional .cockroach.proto.GetResponse get = 1;
  optional .cockroach.proto.PutResponse put = 2;
  optional .cockroach.proto.ConditionalPutResponse conditional_put = 3;
  optional .cockroach.proto.IncrementResponse increment = 4;
  optional .cockroach.proto.DeleteResponse delete = 5;
  optional .cockroach.proto.DeleteRangeResponse delete_range = 6;
  optional .cockroach.proto.ScanResponse scan = 7;
  optional .cockroach.proto.EndTransactionResponse end_transaction = 8;
  optional .cockroach.proto.AdminSplitResponse admin_split = 9;
  optional .cockroach.proto.AdminMergeResponse admin_merge = 10;
  optional .cockroach.proto.HeartbeatTxnResponse heartbeat_txn = 11;
  optional .cockroach.proto.GCResponse gc = 12;
  optional .cockroach.proto.PushTxnResponse push_txn = 13;
  optional .cockroach.proto.RangeLookupResponse range_lookup = 14;
  optional .cockroach.proto.ResolveIntentResponse resolve_intent = 15;
  optional .cockroach.proto.ResolveIntentRangeResponse resolve_intent_range = 16;
  optional .cockroach.proto.MergeResponse merge = 17;
  optional .cockroach.proto.TruncateLogResponse truncate_log = 18;
  optional .cockroach.proto.LeaderLeaseResponse leader_lease = 19;
  optional .cockroach.proto.ReverseScanResponse reverse_scan = 20;
  optional .cockroach.proto.NoopResponse noop = 21;
}

// A BatchRequest contains one or more requests to be executed in
//  parallel, or if applicable (based on write-only commands and
//  range-locality), as a single update.
//  The RequestHeader should contain the Key of the first request
//  in the batch. It also contains the transaction itself; individual
//  calls must not have transactions specified. The same applies to
//  the User and UserPriority fields.
message BatchRequest {
  optional .cockroach.proto.RequestHeader header = 1;
  repeated .cockroach.proto.RequestUnion requests = 2;
}

// A BatchResponse contains one or more responses, one per request
//  corresponding to the requests in the matching BatchRequest. The
//  error in the response header is set to the first error from the
//  slice of responses, if applicable.
message BatchResponse {
  optional .cockroach.proto.ResponseHeader header = 1;
  repeated .cockroach.proto.ResponseUnion responses = 2;
}

